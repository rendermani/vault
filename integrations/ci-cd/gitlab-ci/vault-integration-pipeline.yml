# GitLab CI Pipeline for Vault Infrastructure Integration
# This pipeline demonstrates comprehensive integration with Vault, Consul, Nomad, and Prometheus

variables:
  # Docker registry settings
  REGISTRY: $CI_REGISTRY
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  
  # Vault settings
  VAULT_NAMESPACE: "root"
  
  # Application settings
  APP_NAME: $CI_PROJECT_NAME
  
  # Build settings
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

stages:
  - validate
  - vault-auth
  - test
  - build
  - consul-register
  - nomad-deploy
  - monitoring
  - notify

# Global before_script for common setup
before_script:
  - export VERSION="${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
  - |
    case $CI_COMMIT_REF_NAME in
      main|master)
        export ENVIRONMENT="production"
        export SHOULD_DEPLOY="true"
        ;;
      staging)
        export ENVIRONMENT="staging"
        export SHOULD_DEPLOY="true"
        ;;
      develop)
        export ENVIRONMENT="develop"
        export SHOULD_DEPLOY="true"
        ;;
      *)
        export ENVIRONMENT="review"
        export SHOULD_DEPLOY="false"
        ;;
    esac

# Validation stage
validate-config:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache python3 py3-pip
    - pip3 install pyyaml jsonschema
  script:
    - |
      python3 << 'EOF'
      import yaml
      import json
      import jsonschema
      import os
      import glob
      
      # Validate integration configurations
      config_files = glob.glob("integrations/**/*.yml") + glob.glob("integrations/**/*.yaml")
      
      schema = {
          "type": "object",
          "properties": {
              "vault": {"type": "object"},
              "consul": {"type": "object"}, 
              "nomad": {"type": "object"},
              "prometheus": {"type": "object"}
          }
      }
      
      for file_path in config_files:
          if 'template' in file_path or 'example' in file_path:
              continue
          print(f"Validating {file_path}...")
          try:
              with open(file_path, 'r') as f:
                  config = yaml.safe_load(f)
              if config:
                  print(f"âœ“ {file_path} is valid YAML")
          except Exception as e:
              print(f"âœ— {file_path} validation failed: {e}")
              exit(1)
      
      print("All configurations are valid!")
      EOF
  only:
    - branches

# Vault authentication and secret retrieval
vault-authentication:
  stage: vault-auth
  image: vault:1.15
  script:
    - |
      # Authenticate with Vault using JWT token
      export VAULT_TOKEN=$(vault write -field=token auth/jwt/login \
        role=$VAULT_JWT_ROLE \
        jwt=$CI_JOB_JWT)
      
      # Store token for other jobs
      echo $VAULT_TOKEN > vault_token
      
      # Fetch application secrets
      mkdir -p secrets/
      vault kv get -field=database_url secret/applications/$APP_NAME/$ENVIRONMENT > secrets/database_url
      vault kv get -field=api_key secret/applications/$APP_NAME/$ENVIRONMENT > secrets/api_key
      vault kv get -field=encryption_key secret/applications/$APP_NAME/$ENVIRONMENT > secrets/encryption_key
      
      echo "âœ… Vault authentication and secret retrieval successful"
  artifacts:
    paths:
      - vault_token
      - secrets/
    expire_in: 1 hour
  variables:
    VAULT_ADDR: $VAULT_ADDR
    VAULT_JWT_ROLE: $CI_PROJECT_PATH_SLUG
  only:
    variables:
      - $SHOULD_DEPLOY == "true"

# Testing stage with multiple test types
.test-template: &test-template
  stage: test
  dependencies:
    - vault-authentication
  before_script:
    - export VAULT_TOKEN=$(cat vault_token)
    - export DATABASE_URL=$(cat secrets/database_url)
    - export API_KEY=$(cat secrets/api_key)
    - export ENCRYPTION_KEY=$(cat secrets/encryption_key)

test-python-unit:
  <<: *test-template
  image: python:3.11
  script:
    - cd integrations/python
    - pip install -r requirements.txt
    - pip install pytest pytest-cov pytest-xdist
    - pytest tests/unit/ --cov=vault_integration_sdk --cov-report=xml --cov-report=html -n auto
  coverage: '/TOTAL.+ ([0-9]{1,3}%)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: integrations/python/coverage.xml
    paths:
      - integrations/python/htmlcov/
    expire_in: 1 week
  only:
    - branches

test-javascript-unit:
  <<: *test-template
  image: node:18
  script:
    - cd integrations/javascript
    - npm ci
    - npm test -- --coverage --coverageReporters=cobertura
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: integrations/javascript/coverage/cobertura-coverage.xml
    paths:
      - integrations/javascript/coverage/
    expire_in: 1 week
  only:
    - branches

test-integration:
  <<: *test-template
  image: python:3.11
  services:
    - postgres:15
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST: postgres
  script:
    - cd integrations/tests
    - pip install -r requirements.txt
    - pytest integration/ -v --tb=short --junitxml=integration-report.xml
  artifacts:
    reports:
      junit: integrations/tests/integration-report.xml
    paths:
      - integrations/tests/test-results/
    expire_in: 1 week
  only:
    - branches

test-security:
  <<: *test-template
  image: python:3.11
  script:
    - pip install bandit safety semgrep
    - cd integrations/python
    - bandit -r vault_integration_sdk.py -f json -o security-report.json || true
    - safety check --json --output safety-report.json || true
    - cd ../javascript
    - npm audit --audit-level moderate --json > audit-report.json || true
  artifacts:
    paths:
      - integrations/**/security-report.json
      - integrations/**/safety-report.json  
      - integrations/**/audit-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - branches

# Build and package application
build-application:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - |
      # Build multi-arch image
      docker buildx create --use --name builder --driver docker-container
      docker buildx build \
        --platform linux/amd64,linux/arm64 \
        --tag $IMAGE_NAME:$VERSION \
        --tag $IMAGE_NAME:$CI_COMMIT_REF_SLUG \
        --push .
    - echo "âœ… Docker image built and pushed: $IMAGE_NAME:$VERSION"
  dependencies:
    - test-python-unit
    - test-javascript-unit
  rules:
    - if: $SHOULD_DEPLOY == "true"

# Service registration with Consul
consul-service-registration:
  stage: consul-register
  image: consul:1.16
  dependencies:
    - vault-authentication
    - build-application
  script:
    - |
      export VAULT_TOKEN=$(cat vault_token)
      export CONSUL_HTTP_TOKEN=$CONSUL_TOKEN
      
      # Create service definition
      cat > service.json << EOF
      {
        "Name": "$APP_NAME",
        "ID": "$APP_NAME-$ENVIRONMENT",
        "Tags": [
          "version:$VERSION",
          "environment:$ENVIRONMENT",
          "gitlab-ci"
        ],
        "Address": "service.$ENVIRONMENT.internal",
        "Port": 8080,
        "Meta": {
          "version": "$VERSION",
          "commit": "$CI_COMMIT_SHA",
          "branch": "$CI_COMMIT_REF_NAME",
          "pipeline": "$CI_PIPELINE_ID"
        },
        "Check": {
          "HTTP": "https://service.$ENVIRONMENT.internal:8080/health",
          "Interval": "10s",
          "Timeout": "3s"
        }
      }
      EOF
      
      # Register service
      consul services register service.json
      echo "âœ… Service registered with Consul: $APP_NAME-$ENVIRONMENT"
  variables:
    CONSUL_HTTP_ADDR: $CONSUL_ADDR
  rules:
    - if: $SHOULD_DEPLOY == "true"

# Deployment with Nomad
nomad-deployment:
  stage: nomad-deploy
  image: 
    name: hashicorp/nomad:1.6
    entrypoint: [""]
  dependencies:
    - vault-authentication
    - build-application
    - consul-service-registration
  script:
    - |
      export VAULT_TOKEN=$(cat vault_token)
      
      # Generate Nomad job specification from template
      envsubst < integrations/ci-cd/nomad/app-template.nomad > $APP_NAME.nomad
      
      # Validate job specification
      nomad job validate $APP_NAME.nomad
      
      # Deploy the job
      nomad job run $APP_NAME.nomad
      
      # Wait for deployment to complete
      echo "Waiting for deployment to complete..."
      timeout 300 bash -c 'until nomad job status $APP_NAME | grep -q "running"; do sleep 10; done'
      
      # Verify deployment
      nomad job status $APP_NAME
      echo "âœ… Application deployed successfully with Nomad"
  variables:
    NOMAD_ADDR: $NOMAD_ADDR
    NOMAD_TOKEN: $NOMAD_TOKEN
  environment:
    name: $ENVIRONMENT
    url: https://$APP_NAME.$ENVIRONMENT.internal
  rules:
    - if: $SHOULD_DEPLOY == "true"

# Monitoring setup
setup-monitoring:
  stage: monitoring
  image: appropriate/curl:latest
  dependencies:
    - nomad-deployment
  script:
    - |
      # Push deployment metrics to Prometheus
      cat << EOF | curl -X POST "$PROMETHEUS_PUSHGATEWAY/metrics/job/$APP_NAME/environment/$ENVIRONMENT" --data-binary @-
      # TYPE deployment_info gauge
      deployment_info{version="$VERSION",commit="$CI_COMMIT_SHA",branch="$CI_COMMIT_REF_NAME",pipeline="$CI_PIPELINE_ID"} 1
      # TYPE deployment_timestamp gauge
      deployment_timestamp $(date +%s)
      EOF
      
      echo "âœ… Deployment metrics pushed to Prometheus"
  variables:
    PROMETHEUS_PUSHGATEWAY: $PROMETHEUS_PUSHGATEWAY_URL
  rules:
    - if: $SHOULD_DEPLOY == "true"
  allow_failure: true

# Update Grafana dashboards
update-grafana:
  stage: monitoring
  image: appropriate/curl:latest
  script:
    - |
      # Update application dashboard
      curl -X POST "$GRAFANA_URL/api/dashboards/db" \
        -H "Authorization: Bearer $GRAFANA_TOKEN" \
        -H "Content-Type: application/json" \
        -d @integrations/ci-cd/monitoring/grafana-dashboard.json
      
      echo "âœ… Grafana dashboard updated"
  variables:
    GRAFANA_URL: $GRAFANA_URL
    GRAFANA_TOKEN: $GRAFANA_TOKEN
  rules:
    - if: $SHOULD_DEPLOY == "true" && $ENVIRONMENT == "production"
  allow_failure: true

# Notification stage
notify-success:
  stage: notify
  image: appropriate/curl:latest
  script:
    - |
      # Send success notification to Slack
      curl -X POST -H 'Content-type: application/json' \
        --data "{
          \"attachments\": [
            {
              \"color\": \"good\",
              \"title\": \"Deployment Successful\",
              \"text\": \"Application $APP_NAME deployed successfully to $ENVIRONMENT\",
              \"fields\": [
                {
                  \"title\": \"Version\",
                  \"value\": \"$VERSION\",
                  \"short\": true
                },
                {
                  \"title\": \"Environment\",
                  \"value\": \"$ENVIRONMENT\",
                  \"short\": true
                },
                {
                  \"title\": \"Pipeline\",
                  \"value\": \"$CI_PIPELINE_URL\",
                  \"short\": true
                },
                {
                  \"title\": \"Commit\",
                  \"value\": \"$CI_COMMIT_SHA\",
                  \"short\": true
                }
              ],
              \"footer\": \"GitLab CI\",
              \"ts\": $(date +%s)
            }
          ]
        }" \
        $SLACK_WEBHOOK_URL
  rules:
    - if: $SHOULD_DEPLOY == "true"
      when: on_success
  allow_failure: true

notify-failure:
  stage: notify
  image: appropriate/curl:latest
  script:
    - |
      # Send failure notification to Slack
      curl -X POST -H 'Content-type: application/json' \
        --data "{
          \"attachments\": [
            {
              \"color\": \"danger\",
              \"title\": \"Deployment Failed\",
              \"text\": \"Application $APP_NAME deployment to $ENVIRONMENT failed\",
              \"fields\": [
                {
                  \"title\": \"Version\",
                  \"value\": \"$VERSION\",
                  \"short\": true
                },
                {
                  \"title\": \"Environment\",
                  \"value\": \"$ENVIRONMENT\",
                  \"short\": true
                },
                {
                  \"title\": \"Pipeline\",
                  \"value\": \"$CI_PIPELINE_URL\",
                  \"short\": true
                },
                {
                  \"title\": \"Failed Job\",
                  \"value\": \"$CI_JOB_URL\",
                  \"short\": true
                }
              ],
              \"footer\": \"GitLab CI\",
              \"ts\": $(date +%s)
            }
          ]
        }" \
        $SLACK_WEBHOOK_URL
  rules:
    - if: $SHOULD_DEPLOY == "true"
      when: on_failure
  allow_failure: true

# Rollback job (manual trigger)
rollback-deployment:
  stage: nomad-deploy
  image: 
    name: hashicorp/nomad:1.6
    entrypoint: [""]
  script:
    - |
      echo "ðŸ”„ Rolling back deployment..."
      
      # Stop current job
      nomad job stop -purge $APP_NAME || true
      
      # Deregister from Consul
      consul services deregister $APP_NAME-$ENVIRONMENT || true
      
      # Remove Docker image
      docker rmi $IMAGE_NAME:$VERSION || true
      
      echo "âœ… Rollback completed"
  variables:
    NOMAD_ADDR: $NOMAD_ADDR
    NOMAD_TOKEN: $NOMAD_TOKEN
    CONSUL_HTTP_ADDR: $CONSUL_ADDR
    CONSUL_HTTP_TOKEN: $CONSUL_TOKEN
  when: manual
  allow_failure: true

# Cleanup job for review environments
cleanup-review:
  stage: notify
  image: 
    name: hashicorp/nomad:1.6
    entrypoint: [""]
  script:
    - |
      if [ "$ENVIRONMENT" = "review" ]; then
        echo "ðŸ§¹ Cleaning up review environment..."
        nomad job stop -purge $APP_NAME-$CI_MERGE_REQUEST_IID || true
        consul services deregister $APP_NAME-review-$CI_MERGE_REQUEST_IID || true
        docker rmi $IMAGE_NAME:$VERSION || true
        echo "âœ… Review environment cleaned up"
      fi
  variables:
    NOMAD_ADDR: $NOMAD_ADDR
    NOMAD_TOKEN: $NOMAD_TOKEN
    CONSUL_HTTP_ADDR: $CONSUL_ADDR
    CONSUL_HTTP_TOKEN: $CONSUL_TOKEN
  rules:
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "close"
  allow_failure: true